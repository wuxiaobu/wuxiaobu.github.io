<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 吴小布说</title>
    <link>http://wuxiaobu.github.io/posts/</link>
    <description>Recent content in Posts on 吴小布说</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Wed, 15 Jan 2020 16:25:07 +0800</lastBuildDate>
    
	<atom:link href="http://wuxiaobu.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Go结构体</title>
      <link>http://wuxiaobu.github.io/2020/01/go-struct/</link>
      <pubDate>Wed, 15 Jan 2020 16:25:07 +0800</pubDate>
      
      <guid>http://wuxiaobu.github.io/2020/01/go-struct/</guid>
      <description>Go语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。Go语言中通过结构体的内嵌再配合接口比面向对象具有更高的扩展性和灵活性。
类型别名和自定义类型 自定义类型 在Go语言中有一些基本的数据类型，如string、整型、浮点型、布尔等数据类型， Go语言中可以使用type关键字来定义自定义类型。
自定义类型是定义了一个全新的类型。我们可以基于内置的基本类型定义，也可以通过struct定义。例如：
//将MyInt定义为int类型 type MyInt int 通过type关键字的定义，MyInt就是一种新的类型，它具有int的特性。
类型别名 类型别名是Go1.9版本添加的新功能。
类型别名规定：TypeAlias只是Type的别名，本质上TypeAlias与Type是同一个类型。就像一个孩子小时候有小名、乳名，上学后用学名，英语老师又会给他起英文名，但这些名字都指的是他本人。
type TypeAlias = Type 我们之前见过的rune和byte就是类型别名，他们的定义如下：
type byte = uint8 type rune = int32 类型定义和类型别名的区别 类型别名与类型定义表面上看只有一个等号的差异，我们通过下面的这段代码来理解它们之间的区别。
//类型定义 type NewInt int
//类型别名 type MyInt = int
func main() { var a NewInt var b MyInt
1 2  fmt.Printf(&amp;#34;type of a:%T\n&amp;#34;, a) //type of a:main.NewInt fmt.Printf(&amp;#34;type of b:%T\n&amp;#34;, b) //type of b:int   } 结果显示a的类型是main.NewInt，表示main包下定义的NewInt类型。b的类型是int。MyInt类型只会在代码中存在，编译完成时并不会有MyInt类型。
结构体 Go语言中的基础数据类型可以表示一些事物的基本属性，但是当我们想表达一个事物的全部或部分属性时，这时候再用单一的基本数据类型明显就无法满足需求了，Go语言提供了一种自定义数据类型，可以封装多个基本数据类型，这种数据类型叫结构体，英文名称struct。 也就是我们可以通过struct来定义自己的类型了。</description>
    </item>
    
    <item>
      <title>Go语言基础之基本数据类型</title>
      <link>http://wuxiaobu.github.io/2020/01/go-string/</link>
      <pubDate>Fri, 10 Jan 2020 15:10:45 +0800</pubDate>
      
      <guid>http://wuxiaobu.github.io/2020/01/go-string/</guid>
      <description>Go语言中有丰富的数据类型，除了基本的整型、浮点型、布尔型、字符串外，还有数组、切片、结构体、函数、map、通道（channel）等。Go 语言的基本类型和其他语言大同小异。
基本数据类型 整型 整型分为以下两个大类： 按长度分为：int8、int16、int32、int64 对应的无符号整型：uint8、uint16、uint32、uint64
其中，uint8就是我们熟知的byte型，int16对应C语言中的short型，int64对应C语言中的long型。
   类型 描述     uint8 无符号 8位整型 (0 到 255)   uint16 无符号 16位整型 (0 到 65535)   uint32 无符号 32位整型 (0 到 4294967295)   uint64 无符号 64位整型 (0 到 18446744073709551615)   int8 有符号 8位整型 (-128 到 127)   int16 有符号 16位整型 (-32768 到 32767)   int32 有符号 32位整型 (-2147483648 到 2147483647)   int64 有符号 64位整型 (-9223372036854775808 到 9223372036854775807)    特殊整型    类型 描述     uint 32位操作系统上就是uint32，64位操作系统上就是uint64   int 32位操作系统上就是int32，64位操作系统上就是int64   uintptr 无符号整型，用于存放一个指针    注意： 在使用int和 uint类型时，不能假定它是32位或64位的整型，而是考虑int和uint可能在不同平台上的差异。</description>
    </item>
    
    <item>
      <title>域名解析及各个记录类型的作用与区别</title>
      <link>http://wuxiaobu.github.io/2019/12/dns-resolution/</link>
      <pubDate>Tue, 31 Dec 2019 10:28:44 +0800</pubDate>
      
      <guid>http://wuxiaobu.github.io/2019/12/dns-resolution/</guid>
      <description>趁着给博客换域名这会，好好整理一下域名解析相关的内容。
什么是DNS 域名系统（英文：Domain Name System，缩写：DNS）是互联网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。
域名解析就是域名到IP地址的转换过程。IP地址是网路上标识您站点的数字地址，为了简单好记，采用域名来代替IP地址标识站点地址。域名的解析工作由DNS服务器完成
DNS服务器 我们的电脑想要访问一个网址，首先要取得跟这个网址对应的ID地址。
首先，本机一定要知道DNS服务器的IP地址，通过DNS服务器，才能知道某个IP地址到底是什么。
DNS服务器的IP地址，有可能是动态的，每次上网时由网关分配，这叫DHcp机制；也有可能是事先指定的固定地址。Linunx系统里面，DNS服务器的IP地址保存在在/etc/resolv.conf文件
域名的层级 DNS服务器怎么会知道每个域名的IP地址呢？答案是分级查询。
比如，域名math.stackexchange.com显示为math.stackexchange.com.。这不是疏忽，而是所有域名的尾部，实际上都有一个根域名。 举例来说，www.example.com真正的域名是www.example.com.root，简写为www.example.com.。因为，根域名.root对于所有域名都是一样的，所以平时是省略的。
根服务器主要用来管理互联网的主目录，全世界IPv4根服务器只有13台（这13台IPv4根域名服务器名字分别为“A”至“M”），1个为主根服务器在美国。其余12个均为辅根服务器，其中9个在美国，欧洲2个，位于英国和瑞典，亚洲1个位于日本。根服务器中有经美国政府批准的260个左右的互联网后缀（如．com、．net、.cn等。
根域名的下一级，叫做&amp;rdquo;顶级域名&amp;rdquo;（top-level domain，缩写为TLD），比如.com、.net；
负责解析本身顶级域名下一级域名对应的权威DNS服务器地址。 再下一级叫做&amp;rdquo;次级域名&amp;rdquo;（second-level domain，缩写为SLD），比如www.example.com里面的.example，这一级域名是用户可以注册的；再下一级是主机名（host），比如www.example.com里面的www，又称为&amp;rdquo;三级域名&amp;rdquo;，这是用户在自己的域里面为服务器分配的名称，是用户可以任意分配的。
1  host.sld.tld.root   DNS解析的过程 当一个用户在地址栏输入www.taobao.com时，DNS解析有大致十个过程，如下：
 浏览器先检查自身缓存中有没有被解析过的这个域名对应的ip地址，如果有，解析结束。同时域名被缓存的时间也可通过TTL属性来设置。
 如果浏览器缓存中没有（专业点叫还没命中），浏览器会检查操作系统缓存中有没有对应的已解析过的结果。而操作系统也有一个域名解析的过程。在windows中可通过c盘里一个叫hosts的文件来设置，如果你在这里指定了一个域名对应的ip地址，那浏览器会首先使用这个ip地址。但是这种操作系统级别的域名解析规程也被很多黑客利用，通过修改你的hosts文件里的内容把特定的域名解析到他指定的ip地址上，造成所谓的域名劫持。所以在windows7中将hosts文件设置成了readonly，防止被恶意篡改。
 如果至此还没有命中域名，才会真正的请求本地域名服务器（LDNS）来解析这个域名，这台服务器一般在你的城市的某个角落，距离你不会很远，并且这台服务器的性能都很好，一般都会缓存域名解析结果，大约80%的域名解析到这里就完成了。
 如果LDNS仍然没有命中，就直接跳到Root Server 域名服务器请求解析
 根域名服务器返回给LDNS一个所查询域的主域名服务器（gTLD Server，国际顶尖域名服务器，如.com .cn .org等）地址
 此时LDNS再发送请求给上一步返回的gTLD
 接受请求的gTLD查找并返回这个域名对应的Name Server的地址，这个Name Server就是网站注册的域名服务器
 Name Server根据映射关系表找到目标ip，返回给LDNS
 LDNS缓存这个域名和对应的ip
 LDNS把解析的结果返回给用户，用户根据TTL值缓存到本地系统缓存中，域名解析过程至此结束
  DNS域名解析中添加的各项解析记录  A记录： 将域名指向一个IPv4地址（例如：100.100.100.100），需要增加A记录 CNAME记录： 如果将域名指向一个域名，实现与被指向域名相同的访问效果，需要增加CNAME记录。这个域名一般是主机服务商提供的一个域名 MX记录： 建立电子邮箱服务，将指向邮件服务器地址，需要设置MX记录。建立邮箱时，一般会根据邮箱服务商提供的MX记录填写此记录 NS记录： 域名服务器记录，如果需要把子域名交给其他DNS服务商解析，就需要添加NS记录。比如自己搭建DNS服务器的话也需要做NS记录将主机指向服务器 TXT记录： 可任意填写，可为空。一般做一些验证记录时会使用此项，如：做SPF（反垃圾邮件）记录 AAAA记录： 用来指定主机名（或域名）对应的IPv6地址。A记录对应的是IPV4地址 SRV记录： 添加服务记录服务器服务记录时会添加此项，SRV记录了哪台计算机提供了哪个服务。格式为：服务的名字.</description>
    </item>
    
  </channel>
</rss>